/**
 * Trial Rich Information Application Library (TRIAL)
 * Online Education Technology Group (OETG) @ DT Education & Technology
 */
package com.dtedu.trial.interfaces
{
    import flash.net.URLRequest;

    /**
     * Interface common to all resource bundles.
     *
     * <p>
     * A resource bundle represents a data provider. It can be passed a URLRequest
     * and should then try to satisfy the request. Essentially a resource bundle
     * represents a transparent interface between an arbitrary data source and the
     * requesting code. Data may for example be pulled from databases, web services,
     * embedded classes and so on.
     * </p>
     *
     * <p>
     * The request will normally be in a format as used for plain file system or
     * web server queries, because the final fallback will always be a query to the
     * resource bundle defined by the <code>FileSystemBundle</code> class.
     * </p>
     *
     * <p>
     * A request for a supported datatype must be processed such that a
     * <code>IResourceLoader</code> implementation is returned which eventually
     * either dispatches a completion event (Event.COMPLETE) or an error event
     * (ErrorEvent.ERROR). The actual implementation interals of the loader are up
     * to the resource bundle.
     * </p>
     *
     * <p>
     * When returned by the load function, the loader must be initialized such that
     * the <code>bundle, context, datatype and request</code> properties are set.
     * In case of a loaded IMAGE or SWF, the display property must be a valid
     * <code>DisplayObject</code>, as well. This object must not be exchanged in the
     * later lifetime of the loader.
     * </p>
     *
     * <p>
     * When the load completes successfully, the loaded data must be available via
     * the <code>data</code> property. In case of a loaded display object, i.e. if
     * the data type is IMAGE or SWF, the result must be added to the container
     * available through the <code>display</code> property.
     * </p>
     *
     * <p>
     * When the load fails, no further action is required.
     * </p>
     *
     * <p>
     * The completion or error events <em>must never be fired immediately</em>, so
     * as to allow the calling resource provider a chance to register the handler
     * functions.
     * </p>
     *
     * <p>
     * When implementing a <code>IResourceBundle</code>, be aware that the loaders
     * generated by it <em>are not passed on to the requesting code scope</em>,
     * but only used internally in the <code>ResourceProvider</code> class. Due to
     * lack of pointer (ha, ha) the loader implementation returned by the resource
     * provider class is a wrapper class, which will be populated with the final
     * data if a load succeeds, or used to forward an error event if it fails.
     * </p>
     *
     * <p>
     * Existing implementations are:<br/>
     * <ul>
     * <li>the <code>FileSystemBundle</code>, which normally is the fallback in case
     * other bundles fail to satisfy a request.</li>
     * <li>the <code>EmbeddedBundle</code>, which may be used to map to embedded
     * objects (e.g. via the <code[Embed(source="...")]</code> mechanism, or the
     * Flash IDE's library).</li>
     * </ul>
     * </p>
     *
     * @author fnuecke
     */
    public interface IResourceBundle
    {
        /**
         * Starts trying to load an object based on the given request and returns
         * an instance that can be used to track progress.
         *
         * @param request the requested URL to load.
         * @param type the resource type.
         * @param context optional loader context to use for some loaders.
         * @return an object that can be used to track loading progress and access
         * 			the loaded resource once complete.
         */
        function load(request:URLRequest, type:String, context:*):IResourceLoader;

        /**
         * Method to check if the bundle supports loading a resource of the given
         * type. Bundles must never blindly return <code>true</code> here, but
         * instead check the passed datatype against the constants defined in
         * <code>ResourceType</code>, to avoid issues when new datatypes are added.
         *
         * @param datatype the datatype that is currently being requested.
         * @return whether this bundle supports loading data of that type.
         */
        function supportsType(datatype:String):Boolean;
    }
}
